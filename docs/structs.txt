Проект структур

strucname  elem1 @  elem2 @  + elem3  !  
strucnname 2  elem5 @  elem3 ! 

Имя структуры является списком, в котором хранятся элементы структуры.
Вопрос, если элементы разного размера?
Значит каждый элемент структуры должен иметь средства доступа к нему.
Средства доступа простые - получить элемент, записать элемент.
get store

Strucname -elem1 get   -elem2 store 

Каждый элемент помимо собственно данных содержит ссылку на код для выковыривания и заковыривания данных.
На первых порах можно сделать жирные структуры, один элемент - одна ячейка, даже если это бит. О группировке подумаем после.

WORD: get_qword   @  ;WORD
WORD: set_qword   !  ;WORD

WORD: get_dword   D@ ;WORD
WORD: set_dword   D! ;WORD 
и т. скучно далее.

В свете необходимого хочется чтобы структура сама полностью отдавалась.

Для начала посмотрим на CreateWindowExA

На стек должно быть положено

STRUC: winparam  
           DWORD     dwExStyle
           QWORD     lpClassName
           QWORD     lpWindowName
           DWORD     dwStyle 
           int       x
           int       y
           int       nWidth
           int       nHeight
           QWORD     hWndParent
           QWORD     hMenu
           QWORD     hInstance
           QWORD     lpParam
;STRUC 


WORD: StartWindow    winparam CreateWindow hwnd !   MessageLoop ;WORD 

Предположение
sctrucname кладет на стек содержимое структуры
in strucname делает доступными элементы структуры
in strucname -elem1 get -elem2 set
нужен ли strucsize?
Нужен. Структуру придется выкладывать на стек поэлементно. strucsize в элементах или в байтах?
Если структуры выкладывать на стек поэлементно, то можно просто исполнять get пока не доберемся до конца.
Элементы в структуре - список. Попробуем пока сделать слово STRUC:

 STRUC:  WNDCLASS 
   DWORD      cbSize
   DWORD      style
   QWORD      WndProc
   DWORD      cbClsExtra
   DWORD      cbWndExtra
   QWORD      hInstance
   QWORD      hIcon
   QWORD      hCursor
   QWORD      Background
   QWORD      MenuName
   QWORD      ClassName
   QWORD      hIconSm
;STRUC


WORD: STRUC:  CREATE ;WORD 

WORD: QWORD    CREATE  0 , ;WORD 

Так. Важная часть.
Каждый элемент структуры содержит три ячейки после заголовка. Стандартное поле кода кладет адрес этого элемента. 
НЕТ
Элемент содержит два поля кодя - одно для чтения элемента, другое - для записи. Сответственно слово, указывающее 
размер элемента записывает эти два поля кода. Пока пусть всегда резервируется ячейка.

WORD: QWORD HEADER  ['] (qword_rd) @ ,  ['] (qword_wr) @ ,   0 , ;WORD

Соответственно:

WORD: (qword_rd)   ...  

Значит так.
WORD: QWORD  VARIABLE 0 ,  ['] (qword_rd) @ ,  ['] (qword_wr) @ ,  ;WORD 

И 
WORD: (qword_rd)  @ ;WORD
WORD: (qword_wr)  ! ;WORD

Собственно, тогда можно сократить.

WORD: get   (( elem_addr -- elem_value )   DUP CELL+ @ EXECUTE ;WORD 
WORD: store (( new_value elem_addr --  )   DUP CELL+ CELL+ @ EXECUTE ;WORD 

Тээкс...
WORD: QWORD  VARIABLE    ['] @   ,  ['] !  ,  ;WORD 


WORD: get   (( elem_addr -- elem_value )   DUP CELL+  @ EXECUTE ;WORD 
WORD: store (( new_value elem_addr --  )   DUP CELL+ CELL+  @ EXECUTE ;WORD 


QWORD abc   
Работает. В свете отработанного пришла в голову мысль.

structname get положит содержимое структуры на стек.

Интересно... Как тогда должно работать
strucname -elem1 get  -elem2 get 

Была-то мысль, что strucname задает контекст, в котором лежат -elem1 -elem2 
А и бох сним. Пусть так и работает. 
Мысль другая. strucname должна создавать некий усеченный словарь. Без BADWORD и EXIT.





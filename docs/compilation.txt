О компиляции в Форте

Форт-система суть интерпретатор. Даже не один, а два. Один - адресный интерпретатор, нас он в данной статье будет 
интересовать мало. Второй - интепретатор исходного текста или входного потока, его мы и будем исследовать. Как же он, 
несмотря на то, что интепретатор, умудряется компилировать.

Рассмотрим одну из традиционных реализаций интерпретатора

: INTERPRET ( ->) BEGIN -FIND ?DUP IF
   1+ IF EXECUTE ELSE STATE @ IF , ELSE EXECUTE THEN  THEN
   ELSE NUMBER DPL @ 1+ IF [COMPILE] 2LITERAL
    ELSE DROP [COMPILE] LITERAL THEN THEN ?STACK AGAIN ;
    
Выглядит страшновато. Выделим функциональные части

: INTERPRET ( ->) 
            BEGIN
            -FIND ?DUP IF
                          1+ IF EXECUTE 
                             ELSE STATE
                                @ IF , 
                                  ELSE EXECUTE 
                                  THEN  
                             THEN
                        ELSE 
             NUMBER DPL @ 1+ IF [COMPILE] 2LITERAL
                             ELSE DROP [COMPILE] LITERAL 
                             THEN 
                        THEN 
            ?STACK 
            AGAIN ;
            
  Все равно легко заблудиться в нагромождении вложенных IF..THEN Но, что поделать. Попробуем разобраться.
  Это нагромождение обрамляет бесконечный цикл BEGIN..AGAIN. 
  Затем мы видим первое условие, оно проверяет нашло ли слово -FIND что-нибудь полезное или нет.
  Следом идет проверка, является ли это полезное словом "немедленного" исполнения. Если да, то оно исполняется.
  Иначе же проверяем значение переменной STATE (которая отвечает за переключение состояния интерпретатора).
  Если это состояние "компиляция", то наконец-то компилируем слово, а если "исполнение", то опять исполняем.
  
  Далее мы проверяем, является ли то "неполезное" числом. Двойной или одинарной точности и кладем его на стек или
  компилируем. Проверка стостояния STATE спрятана внутри слов 2LITERAL и LITERAL.
  
  Сложно, не правда ли? 
  
  Рассмотрим теперь более современную версию интерпретатора
  
  
  : INTERPRET_ ( -> ) \ интерпретировать входной поток
  BEGIN
    PARSE-NAME DUP
  WHILE
    SFIND ?DUP
    IF
         STATE @ =
         IF COMPILE, ELSE EXECUTE THEN
    ELSE
         S" NOTFOUND" SFIND 
         IF EXECUTE
         ELSE 2DROP ?SLITERAL THEN
    THEN
    ?STACK
  REPEAT 2DROP
;
Видно, что имеются некоторые усовершенствования.
Слово -FIND разделено на два - PARSE-NAME и SFIND. То-есть функции ввода слова (выделения лексемы из входного потока) 
и поиска его в словаре разделены. 
Изменена обработка чисел. Внедрен поиск слова NOTFOUND. Но в целом сложность и многофункциональность слова INTERPRET 
осталась той-же.


  Давайте попробуем упростить. Так-как слово называется INTERPRET, оставим ему только лишь эту функцию.
  : INTERPRET ( ->) 
            BEGIN
            PARSE SFIND  EXECUTE 
            AGAIN ;
            
  
  
